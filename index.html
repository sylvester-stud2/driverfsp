<!-- second code -->
 <!-- driver.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Driver Delivery Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css' rel='stylesheet' />
    
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore-compat.js"></script>

    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f4f4f4;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 10px;
        }

        .navbar {
            background: #000000;
            color: #FFD700;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .nav-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .dashboard-grid {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-top: 20px;
        }

        @media (min-width: 768px) {
            .dashboard-grid {
                flex-direction: row;
            }
            
            .order-info-column {
                width: 35%;
                max-height: calc(100vh - 100px);
                overflow-y: auto;
            }
            
            .map-container {
                width: 65%;
            }
        }

        .order-card {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 1.5rem;
            margin-bottom: 1rem;
            border: 2px solid #FFD700;
        }

        .login-form {
            max-width: 400px;
            margin: 2rem auto;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #FFD700;
            border-radius: 4px;
            font-size: 1rem;
            margin-top: 0.5rem;
        }

        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid #FFD700;
        }
        @media (max-width: 480px) {
            .order-header h2 {
                font-size: 1.1rem;
            }
        }

        .timestamp {
            font-size: 0.9rem;
            color: #666;
            margin-top: 0.5rem;
        }

        .order-status {
            background: #FFD700;
            color: #000;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            font-weight: 600;
        }

        @media (max-width: 480px) {
            .order-status {
                padding: 0.3rem 0.7rem;
                font-size: 0.85rem;
            }
        }
        @media (max-width: 390px) {
            .order-status {
                display: none;
            }
        }

        .section {
            margin-bottom: 1.5rem;
        }

        .section-title {
            color: #000;
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
        }

        .address-info {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 4px;
            border: 1px solid #FFD700;
        }

        .address-info p {
            margin-bottom: 0.5rem;
            line-height: 1.4;
        }

        .items-list {
            list-style: none;
        }

        .item {
            display: flex;
            justify-content: space-between;
            padding: 0.75rem;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            border: 1px solid #FFD700;
        }

        .price-info {
            background: #000;
            color: #FFD700;
            padding: 1rem;
            border-radius: 4px;
            margin-top: 1rem;
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            font-size: 1.1rem;
        }







        /* Chat Container Styles */
.chat-container {
    position: relative;
    width: 100%;
    height: 400px;
    margin: 15px 0;
    display: none;
    background: white;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    border: 2px solid #FFD700;
    flex-direction: column;
}

/* Chat Header Styles */
.chat-header {
    background: #000000;
    color: #FFD700;
    padding: 12px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 2px solid #FFD700;
}

.chat-header h3 {
    margin: 0;
    font-size: 16px;
    font-weight: 600;
}

.chat-header button {
    background: none;
    border: none;
    color: #FFD700;
    cursor: pointer;
    padding: 4px;
    font-size: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease;
}

.chat-header button:hover {
    transform: scale(1.1);
}

/* Chat Messages Container */
.chat-messages {
    flex: 1;
    height: calc(100% - 110px); /* Header + Input height */
    padding: 16px;
    overflow-y: auto;
    background: white;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

/* Individual Message Styles */
.message {
    max-width: 75%;
    padding: 10px 12px;
    border-radius: 16px;
    position: relative;
    font-size: 14px;
    line-height: 1.4;
    word-break: break-word;
    animation: messageAppear 0.3s ease-out;
}

.message-sent {
    background: #000000;
    color: #FFD700;
    align-self: flex-end;
    margin-left: auto;
    border-bottom-right-radius: 4px;
}

.message-received {
    background: #FFD700;
    color: #000000;
    align-self: flex-start;
    margin-right: auto;
    border-bottom-left-radius: 4px;
}

/* Message Timestamp */
.message-time {
    font-size: 11px;
    opacity: 0.7;
    margin-top: 4px;
    text-align: right;
}

/* Chat Input Area */
.chat-input {
    padding: 12px;
    background: white;
    border-top: 1px solid rgba(255, 215, 0, 0.2);
    display: flex;
    gap: 8px;
    align-items: center;
}

.chat-input input {
    flex: 1;
    padding: 8px 16px;
    border: 2px solid #FFD700;
    border-radius: 20px;
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s ease;
    background: white;
}

.chat-input input:focus {
    border-color: #000000;
}

.chat-input button {
    background: #000000;
    color: #FFD700;
    border: none;
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
}

.chat-input button:hover:not(:disabled) {
    background: #FFD700;
    color: #000000;
    transform: scale(1.05);
}

.chat-input button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Chat Toggle Button */
.chat-toggle-btn {
    background: #000000;
    color: #FFD700;
    border: 2px solid #FFD700;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    position: relative;
    transition: all 0.2s ease;
    padding: 0;
}

.chat-toggle-btn:hover {
    background: #FFD700;
    color: #000000;
    transform: scale(1.05);
}

/* Notification Badge */
.chat-notification {
    position: absolute;
    top: -6px;
    right: -6px;
    background: #FF0000;
    color: white;
    border-radius: 50%;
    min-width: 18px;
    height: 18px;
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 11px;
    font-weight: bold;
    border: 2px solid white;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    padding: 0 4px;
}

/* Scrollbar Styling */
.chat-messages::-webkit-scrollbar {
    width: 6px;
}

.chat-messages::-webkit-scrollbar-track {
    background: rgba(255, 215, 0, 0.1);
    border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 3px;
}

.chat-messages::-webkit-scrollbar-thumb:hover {
    background: rgba(0, 0, 0, 0.3);
}

/* Message Animation */
@keyframes messageAppear {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Responsive Design */
@media (max-width: 768px) {
    .chat-container {
        height: 350px;
        margin: 10px 0;
    }

    .chat-messages {
        padding: 12px;
    }

    .message {
        max-width: 85%;
        font-size: 13px;
    }

    .chat-input {
        padding: 10px;
    }

    .chat-input input {
        padding: 8px 12px;
        font-size: 13px;
    }

    .chat-input button {
        width: 32px;
        height: 32px;
    }
}

@media (max-width: 480px) {
    .chat-container {
        height: 300px;
        margin: 8px 0;
    }

    .chat-header {
        padding: 10px 12px;
    }

    .chat-header h3 {
        font-size: 14px;
    }

    .message {
        max-width: 90%;
        padding: 8px 10px;
        font-size: 12px;
    }

    .message-time {
        font-size: 10px;
    }

    .chat-input {
        padding: 8px;
    }

    .chat-input input {
        padding: 6px 10px;
        font-size: 12px;
    }

    .chat-toggle-btn {
        width: 36px;
        height: 36px;
    }
}

/* Dark Mode Support */
@media (prefers-color-scheme: dark) {
    .chat-container {
        background: #1a1a1a;
        border-color: #FFD700;
    }

    .chat-messages {
        background: #1a1a1a;
    }

    .chat-input {
        background: #1a1a1a;
    }

    .chat-input input {
        background: #2d2d2d;
        color: white;
        border-color: #FFD700;
    }

    .message-received {
        background: #FFD700;
        color: #000000;
    }

    .message-sent {
        background: #000000;
        color: #FFD700;
    }
}















        .action-button {
            width: 100%;
            padding: 1rem;
            margin-top: 1rem;
            background: #000;
            color: #FFD700;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .action-button:hover {
            background: #FFD700;
            color: #000;
        }

        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .map-container {
            height: 400px;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border: 2px solid #FFD700;
        }

        @media (min-width: 768px) {
            .map-container {
                height: calc(100vh - 100px);
                position: sticky;
                top: 80px;
            }
        }

        #map {
            height: 100%;
            width: 100%;
        }

        .error-message {
            color: #dc3545;
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        .success-message {
            color: #28a745;
            font-size: 0.875rem;
            margin-top: 0.5rem;
        }

        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #FFD700;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin: 1rem auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .mapboxgl-marker {
    z-index: 1;
}

.driver-marker {
    z-index: 1000 !important;
}

.driver-popup {
    z-index: 1001 !important;
}

/* Style for the popup content */
.mapboxgl-popup-content {
    padding: 15px;
    border-radius: 8px;
    border: 2px solid #FFD700;
}

/* Custom popup style for driver */
.driver-popup .mapboxgl-popup-content {
    background: rgba(0, 0, 0, 0.8);
    color: #FFD700;
    border: 2px solid #FFD700;
}

.driver-popup h3 {
    margin: 0 0 10px 0;
    color: #FFD700;
}
.driver-marker {
    z-index: 1000 !important;
}

@keyframes pulse {
    0% {
        transform: scale(1);
        opacity: 0.8;
    }
    100% {
        transform: scale(1.5);
        opacity: 0;
    }
}

.status-icon {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    margin-right: 15px;
}

.status-confirmed {
    background: #fff3cd;
    color: #856404;
    animation: bounce 1s infinite;
}

.status-delivering {
    background: #cce5ff;
    color: #004085;
    animation: slide 2s infinite;
}

.status-delivered {
    background: #d4edda;
    color: #155724;
}

@keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
}

@keyframes slide {
    0% { transform: translateX(-5px); }
    50% { transform: translateX(5px); }
    100% { transform: translateX(-5px); }
}




.follow-button {
    padding: 8px 12px;
    border: none;
    background: white;
    box-shadow: 0 0 0 2px rgba(0,0,0,.1);
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    gap: 6px;
    transition: all 0.3s ease;
}

.follow-button.active {
    background: #000000;
    color: #FFD700;
}

.follow-button:hover {
    background: #f4f4f4;
}

.follow-button.active:hover {
    background: #1a1a1a;
}

.follow-button i {
    font-size: 16px;
}

/* Position the follow button in a better spot */
.mapboxgl-ctrl-group.follow-button {
    position: absolute;
    top: 80px;
    right: 10px;
    z-index: 1;
}
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-content">
            <h1>Driver Delivery Dashboard</h1>
            <div id="driver-info"></div>
            <button id="logout-button" class="action-button" style="width: auto; padding: 0.5rem 1rem; margin: 0;" onclick="logout()">Logout</button>
        </div>
    </nav>

    <div id="login-section" class="container">
        <div class="order-card login-form">
            <h2>Driver Login</h2>
            <div class="form-group">
                <input type="email" id="email" class="form-input" placeholder="Email">
            </div>
            <div class="form-group">
                <input type="password" id="password" class="form-input" placeholder="Password">
            </div>
            <button id="login-button" class="action-button" onclick="loginDriver()">Login</button>
            <div id="login-error" class="error-message"></div>
        </div>
    </div>

    <div id="dashboard-content" class="container" style="display: none;">
        <div class="dashboard-grid">
            <div class="order-info-column" id="order-details">
                <!-- Order details will be populated here -->
                 
            </div>
            <div class="map-container">
                <div id="map"></div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
const firebaseConfig = {
      apiKey: "AIzaSyDAvwoIEXPpCnPpxaKgaleiUHENNDGKG4Q",
    authDomain: "sannes-palace.firebaseapp.com",
    projectId: "sannes-palace",
    storageBucket: "sannes-palace.firebasestorage.app",
    messagingSenderId: "932501443001",
    appId: "1:932501443001:web:18151ec8db5c9b11332668",
    measurementId: "G-4VX18JYY5V"
};

// Initialize Firebase
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.firestore();

// Global variables
let map = null;
let currentUser = null;
let currentDriverId = null;
let driverMarker = null;
let watchPositionId = null;
let updateInterval = null;
let routeUpdateInterval = null;
let unsubscribeOrders = null;
let isFollowingDriver = true; // Start with following mode enabled
let userInteractingWithMap = false;
let currentRoute = null;
let currentStepIndex = 0; 
let currentStep = 0;
let speech = null;
let isMuted = false;

// Constants
const STORE_LOCATION = [29.4029, -23.8646]; // [longitude, latitude]
const LOCATION_SETTINGS = {
    enableHighAccuracy: true,
    timeout: 10000,
    maximumAge: 2000
};

function toggleFollowMode() {
    isFollowingDriver = !isFollowingDriver;
    const followButton = document.getElementById('follow-toggle');
    if (followButton) {
        followButton.classList.toggle('active', isFollowingDriver);
        followButton.innerHTML = isFollowingDriver ? 
            '<i class="fas fa-location-arrow"></i> Following' : 
            '<i class="fas fa-location"></i> Follow';
    }
}
// Initialize map
function initializeMap() {
    mapboxgl.accessToken = 'pk.eyJ1Ijoic3lsdmVzdGVyMzMiLCJhIjoiY200a2JsdDJyMG02NjJrc2xzMG40b25wOSJ9.6MP3EOP-rPYvNIoe9UUxlA';
    
    map = new mapboxgl.Map({
        container: 'map',
        style: 'mapbox://styles/mapbox/streets-v11',
        center: STORE_LOCATION,
        zoom: 15,
        pitch: 45,
        bearing: 0,
        antialias: true
    });

    // Add follow mode toggle button
    const followButton = document.createElement('button');
    followButton.id = 'follow-toggle';
    followButton.className = 'mapboxgl-ctrl-group mapboxgl-ctrl follow-button active';
    followButton.innerHTML = '<i class="fas fa-location-arrow"></i> Following';
    followButton.onclick = toggleFollowMode;

    const customControl = document.createElement('div');
    customControl.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
    customControl.appendChild(followButton);
    map.addControl({ 
        onAdd: function() {
            return customControl;
        },
        onRemove: function() {
            customControl.parentNode.removeChild(customControl);
        }
    });

    // Add standard navigation controls
    map.addControl(new mapboxgl.NavigationControl());

    // Add store marker
    new mapboxgl.Marker({ color: '#FF0000' })
        .setLngLat(STORE_LOCATION)
        .setPopup(new mapboxgl.Popup().setHTML('<h3>Store Location</h3><p>Pickup Point</p>'))
        .addTo(map);

    // Track user interaction with map
    map.on('dragstart', () => {
        userInteractingWithMap = true;
        isFollowingDriver = false;
        followButton.classList.remove('active');
        followButton.innerHTML = '<i class="fas fa-location"></i> Follow';
    });

    // Re-enable follow mode after 10 seconds of no interaction
    map.on('dragend', () => {
        setTimeout(() => {
            userInteractingWithMap = false;
        }, 10000);
    });

    map.on('load', () => {
        map.addLayer({
            'id': '3d-buildings',
            'source': 'composite',
            'source-layer': 'building',
            'filter': ['==', 'extrude', 'true'],
            'type': 'fill-extrusion',
            'minzoom': 15,
            'paint': {
                'fill-extrusion-color': '#aaa',
                'fill-extrusion-height': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    15.05, ['get', 'height']
                ],
                'fill-extrusion-base': [
                    'interpolate',
                    ['linear'],
                    ['zoom'],
                    15, 0,
                    15.05, ['get', 'min_height']
                ],
                'fill-extrusion-opacity': 0.6
            }
        });
    });

    return map;
}
function initializeSpeech() {
    if (!window.speechSynthesis) {
        console.error('Speech synthesis not supported');
        return;
    }
    
    speech = new SpeechSynthesisUtterance();
    speech.lang = 'en-GB';
    speech.volume = 1;
    speech.rate = 1;
    speech.pitch = 1;
    
    // Test speech synthesis
    speech.text = "Navigation system ready";
    window.speechSynthesis.speak(speech);
}
// Add sound controls to the map
function addSoundControls() {
    const soundButton = document.createElement('button');
    soundButton.id = 'sound-toggle';
    soundButton.className = 'mapboxgl-ctrl-group mapboxgl-ctrl sound-button active';
    soundButton.innerHTML = '<i class="fas fa-volume-up"></i>';
    soundButton.onclick = toggleSound;

    const customControl = document.createElement('div');
    customControl.className = 'mapboxgl-ctrl mapboxgl-ctrl-group';
    customControl.appendChild(soundButton);
    map.addControl({ 
        onAdd: function() {
            return customControl;
        },
        onRemove: function() {
            customControl.parentNode.removeChild(customControl);
        }
    });
}

// Toggle sound on/off
function toggleSound() {
    isMuted = !isMuted;
    const soundButton = document.getElementById('sound-toggle');
    soundButton.innerHTML = isMuted ? 
        '<i class="fas fa-volume-mute"></i>' : 
        '<i class="fas fa-volume-up"></i>';
    soundButton.classList.toggle('active', !isMuted);
}

// Speak navigation instruction
function speakInstruction(text) {
    if (isMuted || !text || !speech) return;
    
    try {
        // Ensure speech synthesis is ready
        if (!window.speechSynthesis) {
            console.error('Speech synthesis not available');
            return;
        }
        
        window.speechSynthesis.cancel();  // Cancel any ongoing speech
        speech.text = cleanInstruction(text); // Clean the instruction before speaking
        window.speechSynthesis.speak(speech);
        
        // Log for debugging
        console.log('Speaking instruction:', text);
    } catch (error) {
        console.error('Speech synthesis error:', error);
    }
}

// Get clean navigation instruction
function cleanInstruction(instruction) {
    // Remove HTML tags and simplify common terms
    return instruction
        .replace(/<[^>]*>/g, '')
        .replace('Take the rotary', 'At the roundabout')
        .replace('Take the', 'Take')
        .replace(/(\d+)\s*meters/g, '$1 meters')
        .replace(/(\d+)\s*kilometers/g, '$1 kilometers');
}

// Calculate distance between two points
function calculateDistance(point1, point2) {
    const lat1 = point1[1];
    const lon1 = point1[0];
    const lat2 = point2[1];
    const lon2 = point2[0];
    
    const R = 6371e3; // Earth's radius in meters
    const φ1 = lat1 * Math.PI / 180;
    const φ2 = lat2 * Math.PI / 180;
    const Δφ = (lat2 - lat1) * Math.PI / 180;
    const Δλ = (lon2 - lon1) * Math.PI / 180;

    const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) +
            Math.cos(φ1) * Math.cos(φ2) *
            Math.sin(Δλ/2) * Math.sin(Δλ/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));

    return R * c; // Distance in meters
}
function resetNavigationState() {
    currentStepIndex = 0;
    if (currentRoute) {
        currentRoute.legs[0].steps.forEach(step => {
            step.announced400 = false;
            step.announced100 = false;
        });
    }
}
// Update navigation based on current position
function updateNavigation(currentLocation) {
    if (!currentRoute || currentStepIndex >= currentRoute.legs[0].steps.length) return;
    
    const currentStep = currentRoute.legs[0].steps[currentStepIndex];
    const nextManeuverPoint = currentStep.maneuver.location;
    const distanceToManeuver = calculateDistance(currentLocation, nextManeuverPoint);
    console.log('Navigation update:', {
        currentStepIndex,
        distanceToManeuver,
        nextInstruction: currentStep.maneuver.instruction
    });
    if (distanceToManeuver <= 50) {
        // Move to next step
        currentStepIndex++;
        if (currentStepIndex < currentRoute.legs[0].steps.length) {
            const nextStep = currentRoute.legs[0].steps[currentStepIndex];
            nextStep.announced400 = false;
            nextStep.announced100 = false;
            speakInstruction('Now, ' + cleanInstruction(nextStep.maneuver.instruction));
        }
    } else if (distanceToManeuver <= 100 && !currentStep.announced100) {
        speakInstruction(cleanInstruction(currentStep.maneuver.instruction));
        currentStep.announced100 = true;
    } else if (distanceToManeuver <= 400 && !currentStep.announced400) {
        speakInstruction(`In ${Math.round(distanceToManeuver)} meters, ${cleanInstruction(currentStep.maneuver.instruction)}`);
        currentStep.announced400 = true;
    }
}

// Create enhanced driver marker element
function createDriverMarkerElement() {
    const element = document.createElement('div');
    element.className = 'driver-marker';
    // Make marker larger
    element.style.width = '35px';
    element.style.height = '35px';
    element.style.borderRadius = '50%';
    // Create white center
    element.style.backgroundColor = '#FFFFFF';
    element.style.border = '4px solid #FFD700';
    element.style.boxShadow = '0 0 20px #FFD700';
    element.style.position = 'relative';
    element.style.zIndex = '1000'; // Ensure it stays on top
    
    // Add outer glow effect
    const glow = document.createElement('div');
    glow.style.position = 'absolute';
    glow.style.top = '-5px';
    glow.style.left = '-5px';
    glow.style.width = 'calc(100% + 10px)';
    glow.style.height = 'calc(100% + 10px)';
    glow.style.borderRadius = '50%';
    glow.style.backgroundColor = 'rgba(255, 215, 0, 0.3)';
    glow.style.animation = 'pulse 1.5s ease-out infinite';
    element.appendChild(glow);

    // Add second outer glow for more intensity
    const glow2 = document.createElement('div');
    glow2.style.position = 'absolute';
    glow2.style.top = '-10px';
    glow2.style.left = '-10px';
    glow2.style.width = 'calc(100% + 20px)';
    glow2.style.height = 'calc(100% + 20px)';
    glow2.style.borderRadius = '50%';
    glow2.style.backgroundColor = 'rgba(255, 215, 0, 0.2)';
    glow2.style.animation = 'pulse-large 2s ease-out infinite';
    element.insertBefore(glow2, glow);

    // Add pulse animation styles if not already present
    if (!document.getElementById('driver-marker-styles')) {
        const style = document.createElement('style');
        style.id = 'driver-marker-styles';
        style.textContent = `
            @keyframes pulse {
                0% { transform: scale(1); opacity: 0.8; }
                100% { transform: scale(1.5); opacity: 0; }
            }
            @keyframes pulse-large {
                0% { transform: scale(1); opacity: 0.5; }
                100% { transform: scale(2); opacity: 0; }
            }
            .mapboxgl-marker {
                z-index: 1;
            }
            .driver-marker {
                z-index: 1000 !important;
            }
        `;
        document.head.appendChild(style);
    }

    return element;
}

// Initialize driver location with enhanced marker
async function initializeDriverLocation() {
    const driverId = sessionStorage.getItem('driverId');
    if (!driverId) return;

    try {
        const timestamp = new Date().toISOString();
        await db.collection('drivers').doc(driverId).update({
            currentLocation: {
                latitude: STORE_LOCATION[1],
                longitude: STORE_LOCATION[0],
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                clientTimestamp: timestamp,
                isAtStore: true
            },
            lastUpdate: firebase.firestore.FieldValue.serverTimestamp(),
            lastKnownLocation: {
                latitude: STORE_LOCATION[1],
                longitude: STORE_LOCATION[0]
            }
        });

        // Update or create driver marker
        if (!driverMarker) {
            driverMarker = new mapboxgl.Marker({
                element: createDriverMarkerElement(),
                anchor: 'center'
            })
            .setLngLat(STORE_LOCATION)
            .addTo(map);
        }
        
        console.log('Driver location initialized to store location');
    } catch (error) {
        console.error('Error initializing driver location:', error);
    }
}

    















// Chat system state
let chatUnsubscribes =  {};
let currentRole = 'driver';



function cleanupChatListeners(orderId) {
    if (chatUnsubscribes[orderId]) {
        chatUnsubscribes[orderId]();
        delete chatUnsubscribes[orderId];
    }
    if (chatUnsubscribes[`${orderId}-status`]) {
        chatUnsubscribes[`${orderId}-status`]();
        delete chatUnsubscribes[`${orderId}-status`];
    }
}
function createMessageElement(message, orderId) {
    const div = document.createElement('div');
    div.className = `message ${message.sender === currentRole ? 'message-sent' : 'message-received'}`;
    
    const text = document.createElement('div');
    text.textContent = message.text;
    text.style.wordBreak = 'break-word';
    div.appendChild(text);
    
    const time = document.createElement('div');
    time.className = 'message-time';
    const timestamp = message.timestamp ? new Date(message.timestamp.toDate()) : new Date();
    time.textContent = timestamp.toLocaleTimeString([], { 
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        hour12: false
    });
    div.appendChild(time);
    
    // Add read status for sent messages
    if (message.sender === currentRole) {
        const status = document.createElement('div');
        status.className = 'message-status';
        status.textContent = message.read ? '✓✓' : '✓';
        div.appendChild(status);
    }
    
    return div;
}

function toggleOrderChat(orderId) {
    const chatContainer = document.getElementById(`chat-container-${orderId}`);
    if (!chatContainer) return;
    
    const isVisible = chatContainer.style.display === 'flex';
    chatContainer.style.display = isVisible ? 'none' : 'flex';
    
    if (!isVisible) {
        const messagesDiv = document.getElementById(`chat-messages-${orderId}`);
        const inputField = document.getElementById(`message-input-${orderId}`);
        
        // Mark all unread messages as read
        db.collection('orders').doc(orderId)
            .collection('messages')
            .where('read', '==', false)
            .where('sender', '!=', currentRole)
            .get()
            .then(snapshot => {
                const batch = db.batch();
                snapshot.docs.forEach(doc => {
                    batch.update(doc.ref, { read: true });
                });
                return batch.commit();
            });
        
        // Reset notification count
        updateNotificationBadge(orderId, 0);
        
        // Scroll to bottom and focus input
        if (messagesDiv) {
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }
        if (inputField) {
            inputField.focus();
        }
    }
}

function updateNotificationBadge(orderId, count) {
    const badge = document.getElementById(`chat-notification-${orderId}`);
    if (badge) {
        badge.style.display = count > 0 ? 'flex' : 'none';
        badge.textContent = count;
    }
}

async function sendMessage(orderId) {
    const input = document.getElementById(`message-input-${orderId}`);
    const sendButton = document.getElementById(`send-button-${orderId}`);
    
    if (!input || !sendButton) return;
    
    const message = input.value.trim();
    if (!message) return;
    
    try {
        sendButton.disabled = true;
        input.disabled = true;
        
        await db.collection('orders').doc(orderId)
            .collection('messages')
            .add({
                text: message,
                sender: currentRole,
                timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                read: false
            });
        
        input.value = '';
        
    } catch (error) {
        console.error('Error sending message:', error);
        alert('Failed to send message. Please try again.');
    } finally {
        sendButton.disabled = false;
        input.disabled = false;
        input.focus();
    }
}





















async function logout() {
    try {
        // Clean up all chat listeners
        Object.keys(chatUnsubscribes).forEach(key => {
            if (chatUnsubscribes[key]) {
                chatUnsubscribes[key]();
                delete chatUnsubscribes[key];
            }
        });

        // Rest of the logout code...
    } catch (error) {
        console.error("Logout error:", error);
        alert("Error logging out: " + error.message);
    }
}























function handleKeyPress(event, orderId) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage(orderId);
    }
}

async function deleteAllMessages(orderId) {
    try {
        const messages = await db.collection('orders').doc(orderId)
            .collection('messages').get();
            
        const batch = db.batch();
        messages.docs.forEach(doc => {
            batch.delete(doc.ref);
        });
        
        await batch.commit();
    } catch (error) {
        console.error('Error deleting messages:', error);
    }
}

// HTML generator for chat container
function generateChatHTML(orderId) {
    return `
        <div id="chat-container-${orderId}" class="chat-container" style="display: none;">
            <div class="chat-header">
                <h3>Chat with Customer</h3>
                <button onclick="toggleOrderChat('${orderId}')" style="background: none; border: none; color: #FFD700; cursor: pointer;">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <div id="chat-messages-${orderId}" class="chat-messages"></div>
            <div class="chat-input">
                <input type="text" 
                       id="message-input-${orderId}" 
                       placeholder="Type a message..." 
                       onkeypress="handleKeyPress(event, '${orderId}')">
                <button onclick="sendMessage('${orderId}')" 
                        id="send-button-${orderId}">
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    `;
}

// Add this to your order card HTML
function generateChatButton(orderId) {
    return `
        <button onclick="toggleOrderChat('${orderId}')" class="chat-toggle-btn">
            <i class="fas fa-comments"></i>
            <span class="chat-notification" id="chat-notification-${orderId}">0</span>
        </button>
    `;
}



















// Enhanced update driver location function
function updateDriverLocation(position) {
    if (!position?.coords) {
        console.error('Invalid position data received');
        return;
    }

    const { latitude, longitude, accuracy, heading, speed } = position.coords;
    const timestamp = new Date().toISOString();
    const newLocation = [longitude, latitude];

    if (!isValidCoordinate(latitude, longitude)) {
        console.error('Invalid coordinates received:', { latitude, longitude });
        return;
    }

    if (currentRoute) {
        updateNavigation(newLocation);
    }

    // Remove existing marker if it exists
    if (driverMarker) {
        driverMarker.remove();
    }

    // Create new marker
    driverMarker = new mapboxgl.Marker({
        element: createDriverMarkerElement(),
        anchor: 'center',
        rotation: heading || 0 // Use heading for marker rotation
    })
    .setLngLat(newLocation)
    .setPopup(new mapboxgl.Popup({
        offset: 25,
        className: 'driver-popup'
    }).setHTML(`
        <h3>Driver Location</h3>
        <p>Updated: ${new Date().toLocaleTimeString()}</p>
        <p>Accuracy: ${accuracy.toFixed(1)}m</p>
        ${speed ? `<p>Speed: ${(speed * 3.6).toFixed(1)} km/h</p>` : ''}
        ${heading ? `<p>Heading: ${heading.toFixed(1)}°</p>` : ''}
    `))
    .addTo(map);

    // Update map view if following is enabled
    if (isFollowingDriver && !userInteractingWithMap) {
        // Calculate target bearing based on movement
        const targetBearing = heading || map.getBearing();
        
        // Smoothly move the map
        map.easeTo({
            center: newLocation,
            bearing: targetBearing,
            duration: 1000,
            pitch: 60, // Increased pitch for better navigation view
            essential: true // This animation is considered essential for navigation
        });
    }

    updateDriverLocationInFirestore(newLocation, timestamp, {
        accuracy,
        heading,
        speed
    });
    updateRouteIfNeeded(newLocation);
}
// Start location tracking
function startLocationTracking() {
    if (!map || !navigator.geolocation) {
        alert('Location tracking is not supported by your browser');
        return;
    }

    // Initialize driver marker
    if (!driverMarker) {
        driverMarker = new mapboxgl.Marker({
            element: createDriverMarkerElement()
        })
        .setLngLat(STORE_LOCATION)
        .setPopup(new mapboxgl.Popup().setHTML('<h3>Driver Location</h3><p>Starting at store location</p>'))
        .addTo(map);

        initializeDriverLocation();
    }

    // Clear existing trackers
    stopLocationTracking();

    // Start tracking with both watchPosition and interval backup
    const startWatchPosition = () => {
        try {
            watchPositionId = navigator.geolocation.watchPosition(
                updateDriverLocation,
                handleLocationError,
                LOCATION_SETTINGS
            );

            // Backup interval tracking every 2 seconds
            updateInterval = setInterval(() => {
                navigator.geolocation.getCurrentPosition(
                    updateDriverLocation,
                    (error) => {
                        if (error.code === error.TIMEOUT) {
                            console.log('Retrying position update...');
                            navigator.geolocation.getCurrentPosition(
                                updateDriverLocation,
                                handleLocationError,
                                {...LOCATION_SETTINGS, timeout: 15000}
                            );
                        } else {
                            handleLocationError(error);
                        }
                    },
                    LOCATION_SETTINGS
                );
            }, 2000);

            // Route update interval every 10 seconds
            routeUpdateInterval = setInterval(() => {
                if (driverMarker) {
                    const currentPosition = driverMarker.getLngLat();
                    updateRouteIfNeeded([currentPosition.lng, currentPosition.lat]);
                }
            }, 10000);

        } catch (error) {
            console.error('Error starting location tracking:', error);
            alert('Failed to start location tracking. Please refresh and try again.');
        }
    };

    // Request location permission
    navigator.permissions.query({ name: 'geolocation' }).then((permissionStatus) => {
        if (permissionStatus.state === 'granted') {
            startWatchPosition();
        } else if (permissionStatus.state === 'prompt') {
            navigator.geolocation.getCurrentPosition(
                () => startWatchPosition(),
                (error) => {
                    if (error.code === error.PERMISSION_DENIED) {
                        alert('Please enable location access to use delivery tracking');
                    } else {
                        handleLocationError(error);
                    }
                },
                LOCATION_SETTINGS
            );
        } else {
            alert('Location access is denied. Please enable location services.');
        }
    });
}


// Update driver location in Firestore
async function updateDriverLocationInFirestore(location, timestamp, extras = {}) {
    // Test log
    console.log('📍 Updating Firebase:', new Date().toLocaleTimeString(), {
        location,
        timestamp
    });
    
    const driverId = sessionStorage.getItem('driverId');
    if (!driverId) return;

    try {
        await db.collection('drivers').doc(driverId).update({
            currentLocation: {
                latitude: location[1],
                longitude: location[0],
                lastUpdated: firebase.firestore.FieldValue.serverTimestamp(),
                clientTimestamp: timestamp,
                accuracy: extras.accuracy,
                heading: extras.heading,
                speed: extras.speed
            },
            lastUpdate: firebase.firestore.FieldValue.serverTimestamp(),
            lastKnownLocation: {
                latitude: location[1],
                longitude: location[0]
            }
        });
    } catch (error) {
        console.error('Error updating driver location in Firestore:', error);
    }
}

// Update route based on current position
async function updateRouteFromDriver(driverLocation, deliveryLocation) {
    try {
        const response = await fetch(
            `https://api.mapbox.com/directions/v5/mapbox/driving/${driverLocation[0]},${driverLocation[1]};${deliveryLocation[0]},${deliveryLocation[1]}?steps=true&geometries=geojson&access_token=${mapboxgl.accessToken}`
        );

        if (!response.ok) {
            throw new Error('Failed to fetch route');
        }

        const data = await response.json();
        currentRoute = data.routes[0];
        currentStepIndex = 0;
        resetNavigationState();
        // Remove existing route
        if (map.getLayer('route')) {
            map.removeLayer('route');
        }
        if (map.getSource('route')) {
            map.removeSource('route');
        }
        
        
        currentRoute.legs[0].steps.forEach(step => {
            step.announced400 = false;
            step.announced100 = false;
        });
        // Speak initial instruction
        const firstStep = currentRoute.legs[0].steps[0];
        speakInstruction(cleanInstruction(firstStep.maneuver.instruction));
        // Add new route
        map.addSource('route', {
    type: 'geojson',
    data: {
        type: 'Feature',
        properties: {},
        geometry: currentRoute.geometry // Use the route geometry directly
    }
});

        map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
                'line-join': 'round',
                'line-cap': 'round'
            },
            paint: {
                'line-color': '#000000',
                'line-width': 8,
                'line-opacity': 0.8
            }
        });

        // Update map bounds
        const bounds = new mapboxgl.LngLatBounds()
            .extend(driverLocation)
            .extend(deliveryLocation);

        map.fitBounds(bounds, {
            padding: 100,
            duration: 1000
        });

    } catch (error) {
        console.error('Error updating route:', error);
    }
}

// Helper functions
function isValidCoordinate(lat, lng) {
    return !isNaN(lat) && !isNaN(lng) && 
           lat >= -90 && lat <= 90 && 
           lng >= -180 && lng <= 180;
}

function updateRouteIfNeeded(driverLocation) {
    const deliveryMarker = document.querySelector('.mapboxgl-marker:not(.driver-marker)');
    if (deliveryMarker && deliveryMarker._lngLat) {
        updateRouteFromDriver(driverLocation, [deliveryMarker._lngLat.lng, deliveryMarker._lngLat.lat]);
    }
}

function handleLocationError(error) {
    console.error('Location tracking error:', error);
    let errorMessage = 'Location tracking error: ';
    
    switch(error.code) {
        case error.TIMEOUT:
            errorMessage += 'Request timed out. Retrying...';
            navigator.geolocation.getCurrentPosition(
                updateDriverLocation,
                (retryError) => console.error('Retry failed:', retryError),
                {...LOCATION_SETTINGS, timeout: 15000}
            );
            break;
        case error.PERMISSION_DENIED:
            errorMessage += 'Location access denied.';
            break;
        case error.POSITION_UNAVAILABLE:
            errorMessage += 'Location information unavailable.';
            break;
        default:
            errorMessage += error.message || 'Unknown error occurred';
    }
    
    if (driverMarker) {
        driverMarker.setPopup(new mapboxgl.Popup().setHTML(`
            <h3>Driver Location</h3>
            <p style="color: red;">${errorMessage}</p>
        `));
    }
}

// Stop location tracking
function stopLocationTracking() {
    console.log('Stopping location tracking');

    if (watchPositionId) {
        navigator.geolocation.clearWatch(watchPositionId);
        watchPositionId = null;
    }

    if (updateInterval) {
        clearInterval(updateInterval);
        updateInterval = null;
    }

    if (routeUpdateInterval) {
        clearInterval(routeUpdateInterval);
        routeUpdateInterval = null;
    }

    if (driverMarker) {
        driverMarker.remove();
        driverMarker = null;
    }
}

// Login driver function
async function loginDriver() {
    const email = document.getElementById('email').value;
    const pin = document.getElementById('password').value;
    const loginError = document.getElementById('login-error');
    const loginButton = document.getElementById('login-button');

    loginButton.disabled = true;
    loginError.textContent = '';

    try {
        console.log('Attempting login for:', email);

        // First get the driver document
        const driverQuery = await db.collection('drivers')
            .where('email', '==', email.toLowerCase())
            .limit(1)
            .get();

        if (driverQuery.empty) {
            throw new Error('Driver not found');
        }

        const driverDoc = driverQuery.docs[0];
        const driverData = driverDoc.data();

        // Verify PIN and status
        if (driverData.pin !== pin) {
            throw new Error('Invalid PIN');
        }

        if (driverData.status !== 'active') {
            throw new Error('Account is inactive');
        }

        // Sign in with Firebase Auth
        const userCredential = await auth.signInWithEmailAndPassword(email, driverData.tempPassword || pin);
        console.log('Auth successful. UID:', userCredential.user.uid);

        // Store driver info in session
        currentDriverId = driverDoc.id;
        sessionStorage.setItem('driverId', driverDoc.id);
        
        // Update UI
        document.getElementById('driver-info').textContent = 
            `Driver: ${driverData.name} | Vehicle: ${driverData.vehicleNumber}`;
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('dashboard-content').style.display = 'block';
        document.getElementById('logout-button').style.display = 'block';

        // After initializeMap()
        initializeMap();
        addSoundControls(); 
        await initializeDriverLocation();
        startLocationTracking();
        
        // Start listening for deliveries
        listenForActiveDeliveries(driverDoc.id);

    } catch (error) {
        console.error('Login error:', error);
        loginError.textContent = getAuthErrorMessage(error.code) || error.message;
    } finally {
        loginButton.disabled = false;
    }
}
// Update map with delivery location and route
async function updateMapWithDelivery(orderData) {
    if (!map) return;

    try {
        // Get user data for delivery coordinates
        const userDoc = await db.collection('users').doc(orderData.userId).get();
        if (!userDoc.exists) {
            throw new Error('User data not found');
        }

        const userData = userDoc.data();
        
        // Check if coordinates exist
        if (!userData.coordinates || !userData.coordinates.latitude || !userData.coordinates.longitude) {
            throw new Error('Delivery coordinates not found');
        }

        // Use the stored coordinates from user data
        const deliveryCoords = [
            userData.coordinates.longitude,  // Longitude must come first for Mapbox
            userData.coordinates.latitude
        ];
        
        console.log('Using delivery coordinates:', deliveryCoords);
        console.log('Using business coordinates:', STORE_LOCATION);

        // Clear existing markers and routes
        const markers = document.getElementsByClassName('mapboxgl-marker');
        while (markers[0]) {
            markers[0].remove();
        }

        if (map.getLayer('route')) {
            map.removeLayer('route');
        }
        if (map.getSource('route')) {
            map.removeSource('route');
        }

        // Add business location marker
        new mapboxgl.Marker({ color: '#FF0000' })
            .setLngLat(STORE_LOCATION)
            .setPopup(new mapboxgl.Popup().setHTML(`
                <h3>Pickup Location</h3>
                <p>Your Business</p>
            `))
            .addTo(map);

        // Add delivery location marker
        new mapboxgl.Marker({ 
            color: orderData.status === 'delivering' ? '#FFA500' : '#000000'
        })
            .setLngLat(deliveryCoords)
            .setPopup(new mapboxgl.Popup().setHTML(`
                <h3>Delivery Location</h3>
                <p>${userData.street}</p>
                <p>${userData.suburb}, ${userData.city}</p>
                <p>${userData.province}</p>
            `))
            .addTo(map);

        // Get and display the route
        const query = await fetch(
            `https://api.mapbox.com/directions/v5/mapbox/driving/${STORE_LOCATION[0]},${STORE_LOCATION[1]};${deliveryCoords[0]},${deliveryCoords[1]}?steps=true&geometries=geojson&access_token=${mapboxgl.accessToken}`
        );

        const json = await query.json();
        const data = json.routes[0];
        const route = data.geometry.coordinates;

        // Add the route to the map
        map.addSource('route', {
            type: 'geojson',
            data: {
                type: 'Feature',
                properties: {},
                geometry: {
                    type: 'LineString',
                    coordinates: route
                }
            }
        });

        map.addLayer({
            id: 'route',
            type: 'line',
            source: 'route',
            layout: {
                'line-join': 'round',
                'line-cap': 'round'
            },
            paint: {
                'line-color': '#000000',
                'line-width': 8,
                'line-opacity': 0.8
            }
        });

        // Add driver marker if it exists
        if (driverMarker) {
            const currentPosition = driverMarker.getLngLat();
            updateRouteFromDriver([currentPosition.lng, currentPosition.lat], deliveryCoords);
        }

        // Fit map to show all points
        const bounds = new mapboxgl.LngLatBounds()
            .extend(STORE_LOCATION)
            .extend(deliveryCoords);
        
        if (driverMarker) {
            bounds.extend(driverMarker.getLngLat());
        }

        map.fitBounds(bounds, {
            padding: 100,
            duration: 1000
        });

    } catch (error) {
        console.error('Error updating map:', error);
        // Show error on map
        new mapboxgl.Popup()
            .setLngLat(map.getCenter())
            .setHTML(`<h3>Error loading delivery location</h3><p>${error.message}</p>`)
            .addTo(map);
    }
}
// Logout function
async function logout() {
    try {
        // Clean up listeners and tracking
        stopLocationTracking();
        if (unsubscribeOrders) {
            unsubscribeOrders();
        }

        // Clear session
        sessionStorage.clear();
        currentDriverId = null;
        currentUser = null;

        // Sign out from Firebase
        await auth.signOut();

        // Reset UI
        document.getElementById('login-section').style.display = 'block';
        document.getElementById('dashboard-content').style.display = 'none';
        document.getElementById('logout-button').style.display = 'none';
        document.getElementById('driver-info').textContent = '';
        document.getElementById('order-details').innerHTML = '';

    } catch (error) {
        console.error("Logout error:", error);
        alert("Error logging out: " + error.message);
    }
}

// Listen for active deliveries
function listenForActiveDeliveries(driverId) {
    if (!driverId) {
        console.error('No driver ID provided');
        return;
    }

    if (unsubscribeOrders) {
        unsubscribeOrders();
    }

    const orderDetails = document.getElementById('order-details');
    orderDetails.innerHTML = '<div class="loading-spinner"></div>';

    unsubscribeOrders = db.collection('orders')
        .where('driverId', '==', driverId)
        .where('status', '==', 'delivering')
        .orderBy('timestamp', 'asc') // Add this line to sort by timestamp
        .onSnapshot(async (snapshot) => {
            console.log('Orders snapshot received:', snapshot.size, 'documents');
            orderDetails.innerHTML = '';
            
            if (snapshot.empty) {
                orderDetails.innerHTML = `
                    <div class="order-card">
                        <div class="section">
                            <h3>No Active Deliveries</h3>
                            <p>Waiting for new orders...</p>
                        </div>
                    </div>`;
                return;
            }

            // Create an array of orders to sort them
            const orders = [];
            for (const doc of snapshot.docs) {
                orders.push({
                    id: doc.id,
                    data: doc.data()
                });
            }

            // Sort orders by timestamp in descending order (newest first)
            orders.sort((a, b) => {
                const timestampA = a.data.timestamp?.seconds || 0;
                const timestampB = b.data.timestamp?.seconds || 0;
                return timestampB - timestampA;
            });

            // Display orders in sorted order
            for (const order of orders) {
                await displayOrderDetails(order.data, order.id);
                try {
                    await updateMapWithDelivery(order.data);
                } catch (error) {
                    console.error('Error updating map for order:', order.id, error);
                }
            }
        }, (error) => {
            console.error('Error fetching orders:', error);
            orderDetails.innerHTML = `
                <div class="order-card">
                    <div class="section">
                        <h3>Error Loading Orders</h3>
                        <p class="error-message">${error.message}</p>
                    </div>
                </div>`;
        });
}











function initializeChat(orderId) {
    if (!orderId) {
        console.error('No orderId provided to initializeChat');
        return;
    }
    
    // Clear previous listener for this specific order if it exists
    if (chatUnsubscribes[orderId]) {
        chatUnsubscribes[orderId]();
    }
    
    let unreadCount = 0;
    
    // Listen to messages for this order
    chatUnsubscribes[orderId] = db.collection('orders').doc(orderId)
        .collection('messages')
        .orderBy('timestamp', 'asc')
        .onSnapshot(snapshot => {
            const messagesDiv = document.getElementById(`chat-messages-${orderId}`);
            if (!messagesDiv) return;
            
            const chatContainer = document.getElementById(`chat-container-${orderId}`);
            const isVisible = chatContainer.style.display === 'flex';
            
            let isFirstLoad = !messagesDiv.hasChildNodes();
            
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const message = change.doc.data();
                    const messageElem = createMessageElement(message, orderId);
                    messagesDiv.appendChild(messageElem);
                    
                    // Update unread count for customer messages if chat is not visible
                    if (!isFirstLoad && 
                        message.sender === 'customer' && 
                        !isVisible) {
                        unreadCount++;
                        updateNotificationBadge(orderId, unreadCount);
                    }
                    
                    // Mark customer messages as read if chat is visible
                    if (message.sender === 'customer' && 
                        !message.read && 
                        isVisible) {
                        change.doc.ref.update({ read: true });
                    }
                }
            });
            
            // Scroll to bottom for new messages
            if (!isFirstLoad) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            }
        });

    // Listen for order status changes
    const orderStatusUnsubscribe = db.collection('orders').doc(orderId)
        .onSnapshot(doc => {
            if (doc.exists && doc.data().status === 'delivered') {
                deleteAllMessages(orderId);
                if (chatUnsubscribes[orderId]) {
                    chatUnsubscribes[orderId]();
                    delete chatUnsubscribes[orderId];
                }
            }
        });
        
    // Store order status listener with chat listeners
    chatUnsubscribes[`${orderId}-status`] = orderStatusUnsubscribe;
}









// Display order details
async function displayOrderDetails(orderData, orderId) {
    const userDoc = await db.collection('users').doc(orderData.userId).get();
    const userData = userDoc.data();
    

    const orderHtml = `
        <div class="order-card" id="order-card-${orderId}">
            <div class="order-header">
                <div>
                    <h2>Order #${orderId}</h2>
                    <div class="timestamp">Ordered: ${formatTimestamp(orderData.timestamp)}</div>
                </div>
                <div style="display: flex; align-items: center; gap: 10px;">
                    <button onclick="toggleOrderChat('${orderId}')" class="chat-toggle-btn">
                        <i class="fas fa-comments"></i>
                        <span class="chat-notification" id="chat-notification-${orderId}">0</span>
                    </button>
                    <span class="order-status">Delivering</span>
                </div>
            </div>

            <!-- Chat container for this specific order -->
            <div id="chat-container-${orderId}" class="chat-container" style="display: none;">
                <div class="chat-header">
                    <h3>Chat with Customer</h3>
                    <button onclick="toggleOrderChat('${orderId}')" style="background: none; border: none; color: #FFD700; cursor: pointer;">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
                <div id="chat-messages-${orderId}" class="chat-messages"></div>
                <div class="chat-input">
                    <input type="text" id="message-input-${orderId}" placeholder="Type a message..." 
                           onkeypress="handleKeyPress(event, '${orderId}')">
                    <button onclick="sendMessage('${orderId}')" id="send-button-${orderId}">
                        <i class="fas fa-paper-plane"></i>
                    </button>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">Customer Details</h3>
                <div class="address-info">
                    <p><strong>Name:</strong> ${userData.fullName || 'N/A'}</p>
                    <p><strong>Phone:</strong> ${userData.phone || 'N/A'}</p>
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">Delivery Location</h3>
                <div class="address-info">
                    <p><strong>Address:</strong></p>
                    <p>${userData.street}</p>
                    <p>${userData.suburb}, ${userData.city}</p>
                    <p>${userData.province}, ${userData.postalCode}</p>
                    ${userData.coordinates ? `
                        <p><strong>GPS Coordinates:</strong></p>
                        <p>Latitude: ${userData.coordinates.latitude}</p>
                        <p>Longitude: ${userData.coordinates.longitude}</p>
                    ` : ''}
                </div>
            </div>

            <div class="section">
                <h3 class="section-title">Order Items</h3>
                <ul class="items-list">
                    ${orderData.items.map(item => `
                        <li class="item">
                            <span>${item.quantity}x ${item.name}</span>
                        </li>
                    `).join('')}
                </ul>
            </div>

            <button class="action-button" onclick="updateOrderStatus('${orderId}', 'delivered')">
                Mark as Delivered
            </button>
        </div>
    `;

    const orderDetails = document.getElementById('order-details');
    if (orderDetails.querySelector('.loading-spinner')) {
        orderDetails.innerHTML = orderHtml;
    } else {
        orderDetails.insertAdjacentHTML('beforeend', orderHtml);
    }
    
    // Initialize chat after adding the HTML
    initializeChat(orderId, 'driver');
}
// Update order status
async function updateOrderStatus(orderId, newStatus) {
    try {
        const driverId = sessionStorage.getItem('driverId');
        if (!driverId) {
            throw new Error('Driver ID not found. Please login again.');
        }

        console.log('Updating order status:', { orderId, newStatus, driverId });

        const orderRef = db.collection('orders').doc(orderId);
        const orderDoc = await orderRef.get();
        if (newStatus === 'delivered') {
            cleanupChatListeners(orderId);
        }
        if (!orderDoc.exists) {
            throw new Error('Order not found');
        }

        const orderData = orderDoc.data();
        
        // Verify this driver owns this delivery
        if (orderData.driverId !== driverId) {
            throw new Error('Unauthorized to update this order');
        }

        // Verify current status is 'delivering'
        if (orderData.status !== 'delivering') {
            throw new Error('Order must be in delivering status to be marked as delivered');
        }

        // Update the order status
        await orderRef.update({
            status: 'delivered',
            deliveredAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        // Update driver's delivery count
        try {
            await db.collection('drivers').doc(driverId).update({
                totalDeliveries: firebase.firestore.FieldValue.increment(1),
                lastDeliveryAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('Driver delivery count updated');
        } catch (error) {
            console.error('Error updating driver stats:', error);
        }

        alert('Order successfully marked as delivered');

    } catch (error) {
        console.error('Error updating order status:', error);
        alert(error.message || 'Failed to update order status');
    }
}

// Format timestamp
function formatTimestamp(timestamp) {
    if (timestamp?.seconds) {
        return new Date(timestamp.seconds * 1000).toLocaleString('en-ZA', {
            day: 'numeric',
            month: 'long',
            year: 'numeric',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            timeZoneName: 'short'
        });
    }
    return new Date(timestamp).toLocaleString('en-ZA', {
        day: 'numeric',
        month: 'long',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZoneName: 'short'
    });
}

// Get auth error message
function getAuthErrorMessage(code) {
    const errorMessages = {
        'auth/user-not-found': 'No account found with this email.',
        'auth/wrong-password': 'Invalid email or PIN.',
        'auth/too-many-requests': 'Too many login attempts. Please try again later.',
        'auth/network-request-failed': 'Network error. Please check your connection.'
    };
    return errorMessages[code] || 'Login failed. Please try again.';
}

// Debug logging utility
function logDebug(section, message, data = null) {
    const logMessage = `[${section}] ${message}`;
    console.log(logMessage, data || '');
}

// Auth state listener
auth.onAuthStateChanged((user) => {
    logDebug('Auth', 'Auth state changed', { 
        userExists: !!user,
        email: user?.email 
    });

    if (user) {
        const driverId = sessionStorage.getItem('driverId');
        logDebug('Auth', 'Retrieved driverId from session', { driverId });
        
        if (driverId) {
            listenForActiveDeliveries(driverId);
        }
    } else {
        if (unsubscribeOrders) {
            unsubscribeOrders();
        }
        document.getElementById('login-section').style.display = 'block';
        document.getElementById('dashboard-content').style.display = 'none';
        document.getElementById('logout-button').style.display = 'none';
        document.getElementById('driver-info').textContent = '';
    }
});

// Add event listeners for form submission
document.addEventListener('DOMContentLoaded', () => {
    initializeSpeech();
    const emailInput = document.getElementById('email');
    const passwordInput = document.getElementById('password');

    emailInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            passwordInput.focus();
        }
    });

    passwordInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            loginDriver();
        }
    });
});
    </script>
</body>
</html>
